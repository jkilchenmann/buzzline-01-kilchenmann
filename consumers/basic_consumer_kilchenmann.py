"""
basic_consumer_kilchenmann.py

Read a log file as it is being written. 
"""

#####################################
# Import Modules
#####################################

# Import packages from Python Standard Library
import os
import time

# Import functions from local modules
from utils.utils_logger import logger, get_log_file_path

#####################################
# Define a function to process a single message
# #####################################

import time
from datetime import datetime, timedelta

def process_message(log_file) -> None:
    """
    Read a log file and process each message.

    Args:
        log_file (str): The path to the log file to read.
    """
    with open(log_file, "r") as file:
        # Move to the end of the file
        file.seek(0, os.SEEK_END)
        print("Consumer is ready and waiting for a new log message...")

        last_position = file.tell()  # Start at the end of the file
        processed_lines = set()  # Keep track of processed messages
        alert_times = {}  # Store timestamps for recent alerts

        while True:
            file.seek(last_position)  # Move to the last known position
            line = file.readline()
            last_position = file.tell()  # Update the position after reading

            # If the line is empty, no new message is available
            if not line.strip():
                time.sleep(2.5)  # Sleep slightly less than the producer interval
                continue

            # Process the line
            message = line.strip()

            # Skip already processed messages
            if message in processed_lines:
                continue
            processed_lines.add(message)  # Mark this line as processed

            print(f"Consumed log message: {message}")

            # Monitor and alert on special conditions
            if "Cleveland" in message:
                now = datetime.now()
                # Check if we need to throttle the alert for "Cleveland"
                if "Cleveland" in alert_times:
                    last_alert_time = alert_times["Cleveland"]
                    if now - last_alert_time < timedelta(seconds=2):
                        # Skip alert if it's too soon after the last one
                        continue

                # Log and print the alert
                print(f"ALERT: Cleveland!")
                logger.warning(f"Cleveland!")
                alert_times["Cleveland"] = now  # Update the last alert time

#####################################
# Define main function for this script.
#####################################


def main() -> None:
    """Main entry point."""

    logger.info("START...")

    # Call the function we imported from utils/utils_logger module
    # to get the path to the log file being generated by the producer.
    # Assign the return value to a local variable.
    log_file_path = get_log_file_path()
    logger.info(f"Reading file located at {log_file_path}.")

    try:
        # Try to call the process_message function with the log file path
        # as an argument. We know things will go wrong
        # eventually when the user stops the process, so we use a try block.
        process_message(log_file_path)

    except KeyboardInterrupt:
        print("User stopped the process.")

    logger.info("END.....")


#####################################
# Conditional Execution
#####################################

# If this file is the one being executed, call the main() function
if __name__ == "__main__":
    main()
